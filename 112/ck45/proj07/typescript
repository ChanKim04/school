Script started on Mon 03 Apr 2017 06:26:43 PM EDT
ck45@thompson:~/workspace/112/proj07$ ls
anorexia.txt  main.cpp		     ReversePoemTester.h  StackTester.cpp
cats.txt      ReversePoem.cpp	     Stack.cpp		  StackTester.h
Debug	      ReversePoem.h	     StackException.h	  tester.cpp
love.txt      ReversePoemTester.cpp  Stack.h		  typescript
ck45@thompson:~/workspace/112/proj07$ cas   cat main.cpp
/*
 * main.cpp
 *
 *  Created on: 2017. 3. 30.
 *      Author: Chan Kim
 */

#include "ReversePoem.h"
#include <iostream>
using namespace std;

int main() {
   cout << "\nEnter the name of the poem file: ";
   string poemFile;
   cin >> poemFile;

   ReversePoem reversePoem(poemFile);
   cout << reversePoem.getTitle() << "\n"
        << reversePoem.getAuthor() << "\n"
        << "\n*** Top-To-Bottom ***\n\n"
        << reversePoem.getBody()
        << "\n\n*** Bottom-To-Top ***\n\n"
        << reversePoem.getBodyReversed()
        << endl;
}


ck45@thompson:~/workspace/112/proj07$ s cat Stack.h
/* Stack.h provides a (dynamic-array-based) Stack class.
 * Joel Adams, for CS 112 at Calvin College.
 * Student Name: Chan Kim (ck45)
 * Date: 03/28/2017
 * 
 * Invariant: mySize == 0 && isEmpty() && !isFull()
 *         || mySize == myCapacity && !isEmpty() && isFull()
 *         || mySize > 0 && mySize < myCapacity && !isEmpty() && !isFull().
 * Notes: 
 * 1. Member mySize always contains the index of the next empty space in myArray
 *        (the index of the array element into which the next pushed item will be placed).
 * 2. Sending push() to a full Stack throws the exception Stack::Overflow.
 * 3. Sending pop() or peekTop() to an empty Stack throws the exception Stack::Underflow.
 */

#ifndef STACK_H_
#define STACK_H_

#include "StackException.h"
#include <string>
#include <iostream>
using namespace std;

///typedef int Item;
template<class Item>

class Stack {
public:
	Stack(unsigned capacity);
	Stack(const Stack<Item>& original);
	~Stack();
	Stack<Item>& operator=(const Stack<Item>& original);
	bool isEmpty() const {return mySize == 0;}
	bool isFull() {return mySize >= myCapacity;}
	void push(const Item& it);
	Item peekTop() const ;
	Item pop();
	unsigned getSize() {return mySize;}
	unsigned getCapacity() {return myCapacity;}
	void setCapacity(unsigned newCapacity);
	

protected:
	void makeCopyOf(const Stack<Item>& original);
	
private:
	unsigned myCapacity;
	unsigned mySize;
	Item*    myArray;
	friend class StackTester;
};

/* explicit-value constructor
 * Parameter: capacity, an unsigned value.
 * Precondition: capacity > 0.
 * Postcondition: mySize == 0 && myCapacity == capacity
 *              && myArray contains the address of a dynamic array of 'capacity' entries.
 */
template<class Item>
Stack<Item>::Stack(unsigned capacity) {
   if (capacity <= 0) {
   		   throw StackException("Stack(size)", "size must be positive!");
   }
   mySize = 0;
   myCapacity = capacity;
   myArray = new Item[capacity];
}

/* copy constructor
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original.
 */
template<class Item>
Stack<Item>::Stack(const Stack<Item>& original) {
	makeCopyOf(original);
}

/* utility method containing code refactored from
 *  the copy constructor and operator=.
 * Parameter: original, a Stack (const reference).
 * Precondition: original.myCapacity > 0.
 * Postcondition: I am a copy of original.
 */
template<class Item>
void Stack<Item>::makeCopyOf(const Stack<Item>& original) {
	myCapacity = original.myCapacity;
	myArray = new Item[myCapacity];

	for (unsigned i = 0; i < myCapacity; i++) {
		myArray[i] = original.myArray[i];
	}
	mySize = original.mySize;
}

/* destructor
 * Postcondition: myCapacity == 0 && mySize == 0
 *             && myArray has been deallocated.
 */
template<class Item>
Stack<Item>::~Stack() {
	delete [] myArray;
	myArray = NULL;
	myCapacity = 0;
	mySize = 0;
}

/* assignment operator
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original
 *              && I have been returned.
 */
template<class Item>
Stack<Item>& Stack<Item>::operator=(const Stack<Item>& original) {
	if (this != &original) {
		delete [] myArray;
		makeCopyOf(original);
	}
	return *this;
}
/* push Item
 * Parameter: it, an Item.
 * Postcondition: places it on top of the Stack
 */
template<class Item>
void Stack<Item>::push(const Item& it) {
	if (this -> isFull()) {
		throw StackException("push()", "stack is full");
	}
	myArray[mySize++] = it;
}

/* peekTop
 * Postcondition: returns the top item from the Stack (without modifying the Stack)
 */
template<class Item>
Item Stack<Item>::peekTop() const {
	if ( isEmpty() ) {
		throw StackException("peekTop()", "stack is empty");
	}
	return myArray[mySize-1];
}
/* pop
 * Postcondition: removes and returns the top item from the Stack
 */
template<class Item>
Item Stack<Item>::pop(){
	if ( isEmpty() ) {
		throw StackException("peek()", "stack is empty");
	}
	return myArray[--mySize];
}
/* set capacity
 * Parameter: newCapacity, an unsigned.
 * Postcondition: set the capacity with new value
 */
template<class Item>
void Stack<Item>::setCapacity(unsigned newCapacity) {
	if (newCapacity < mySize) {
		throw StackException("setCapacity(newCapacity)", "Capacity must be bigger than size");
	}

	Item* newArray = new Item[newCapacity];

	for (unsigned i = 0; i < myCapacity; i++) {
		newArray[i] = myArray[i];
	}
	delete [] myArray;
	myCapacity = newCapacity;
	myArray = newArray;
}

#endif

ck45@thompson:~/workspace/112/proj07$ cat Stack.cpp
/* Stack.cpp defines the dynamically allocated (array-based ) Stack operations.
 * Joel Adams, for CS 112 at Calvin College.
 * Student Name: Chan Kim (ck45)
 * Date: 03/28/2017
 */

#include "Stack.h"


ck45@thompson:~/workspace/112/proj07$ cat ReversePoem.h
/*
 * ReversePoem.h
 *
 *  Created on: 2017. 3. 30.
 *      Author: Chan Kim
 */

#ifndef REVERSEPOEM_H_
#define REVERSEPOEM_H_
#include "Stack.h"
#include <iostream>
#include <fstream>
#include <cassert>
using namespace std;

class ReversePoem {
public:
	ReversePoem(const string& fileName);
	string getTitle() const{return myTitle;}
	string getAuthor() const{return myAuthor;}
	string getBody() const{return myBody;}
	string getBodyReversed() const{return myBodyReversed;}

private:
	string myTitle;
	string myAuthor;
	string myBody;
	string myBodyReversed;
};

#endif /* REVERSEPOEM_H_ */
ck45@thompson:~/workspace/112/proj07$ cat ReversePoem.cpp
/*
 * ReversePoem.cpp
 *
 *  Created on: 2017. 3. 30.
 *      Author: Chan Kim
 */

#include "ReversePoem.h"

/* ReversePoem constructor
 * Parameter: fileName, a string
 * Postcondition: read myTitle, myAuthor, myBody from text file
 * 					and reverse myBody and store it into myBodyReversed
 */
ReversePoem::ReversePoem(const string& fileName) {
	ifstream fin(fileName.c_str());
	assert( fin.is_open() );
	string line;
	getline(fin,line);
	myTitle = line;
	getline(fin,line);
	myAuthor = line;
	getline(fin,line);
	Stack<string> Body(1);
	while(!fin.eof()) {
		getline(fin,line);
		try {
			Body.push(line);
		} catch (StackException& se) {
			Body.setCapacity(Body.getCapacity()*2);
			Body.push(line);
		}
		myBody = myBody + line + "\n";
	}
	while(!Body.isEmpty()) {
		myBodyReversed = myBodyReversed + Body.pop() + "\n";
	}
	fin.close();
}

ck45@thompson:~/workspace/112/proj07$ cat StackException.h
/* StackException.h models exceptions in stack operations.
 * Joel Adams, for CS 112 at Calvin College.
 * Student Name: Chan Kim (ck45)
 * Date: 03/28/2017
 */

#ifndef STACK_EXCEPTION
#define STACK_EXCEPTION

#include <iostream>
using namespace std;

 
class StackException {
public:
   StackException(const string& whereThrown,
                  const string& message) { 
       myLocation = whereThrown; 
       myMessage = message; 
   }

   string asString() const {
       return "*** StackException in " +
               myLocation + ": " + myMessage; 
   }

private:
   string myLocation;
   string myMessage;
};  // StackException


/* Function to allow a StackException (or a subclass) to be displayed
 * via an ostream.
 * Parameters: out, an ostream;
 *             se, a StackException.
 * Postcondition: the string representation of se has been inserted
 * into out
 *             && return-value == out.
 */
inline ostream& operator<<(ostream& out, const StackException& se) {
      out << se.asString();
      return out;
}

#endif

ck45@thompson:~/workspace/112/proj07$ cat tester.cpp
/* tester.cpp is a "driver" to run the tests in the StackTester class.
 * Joel Adams, for CS 112 at Calvin College.
 */
 
#include "StackTester.h"
#include "ReversePoemTester.h"
int main() {
	StackTester st;
	st.runTests();
	ReversePoemTester rpt;
	rpt.runTests();
}

ck45@thompson:~/workspace/112/proj07$ cat StackTester.h
/* StackTester.h declares a test-class for a dynamically allocated (array) Stack.
 * Joel Adams, for CS 112 at Calvin College
 */

#ifndef STACKTESTER_H_
#define STACKTESTER_H_


class StackTester {
public:
	void runTests();
	void testConstructor();
	void testIsEmpty();
	void testPushAndIsFull();
	void testPushPeekTopAndIsFull();
	void testGetTop();
	void testPop();
	void testCopyConstructor();
	void testAssignment();
	void testDestructor();
	void testGetSize();
	void testGetCapacity();
	void testSetCapacity();
};

#endif /*STACKTESTER_H_*/

ck45@thompson:~/workspace/112/proj07$ Stack     cat StackTes        StackTester.cpp
/* StackTester.cpp defines test-methods for the 
 *  dynamically allocated (array) Stack operations
 * Joel Adams, for CS 112 at Calvin College
 */

#include "StackTester.h"
#include "Stack.h"
#include <iostream>  // cout, cerr, ...
#include <cassert>   // assert()
#include <cstdlib>   // exit()
using namespace std;

void StackTester::runTests() {
	cout << "Testing Stack class..." << endl;
	testConstructor();
	testIsEmpty();
	testPushPeekTopAndIsFull();
	testPop();
	testCopyConstructor();
	testAssignment();
	testDestructor();
	testGetSize();
	testGetCapacity();
	testSetCapacity();
	cout << "All tests passed!" << endl;
}

void StackTester::testConstructor() {
	cout << "- Testing constructor... " << flush;
	// invalid parameter
	try {
		Stack<int> s1(0);
		cerr << "\nConstructed stack of size 0\n";
		exit(1);
	} catch (StackException& se) {
		cout << se << flush;
	}
	cout << " 1 " << flush;
	// valid parameter
	Stack<int> s2(3);
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testIsEmpty() {
	cout << "- Testing isEmpty()... " << flush;
	// capacity 1
	Stack<int> s1(1);
	assert( s1.isEmpty() );
	cout << " 1 " << flush;
	// capacity > 1
	Stack<int> s2(3);
	assert( s2.isEmpty() );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}


void StackTester::testPushPeekTopAndIsFull() {
	cout << "- Testing push()... " << flush;
	// test with capacity 1
	Stack<int> s1(1);
	s1.push(11);
	assert( s1.peekTop() == 11 );
	assert( !s1.isEmpty() );
	assert( s1.isFull() );
	try {
		s1.push(22);
		cerr << "\npush() worked on a full stack (size 1)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 1 " << flush;
	}
	// test with capacity > 1
	Stack<int> s2(3);
	s2.push(11);
	assert( s2.peekTop() == 11 );
	s2.push(22);
	assert( s2.peekTop() == 22 );
	s2.push(33);
	assert( s2.peekTop() == 33 );
	try {
		s2.push(44);
		cerr << "\npush() worked on a full stack (size 3)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 2 " << flush;
	}
	cout << " Passed! " << endl;
}

void StackTester::testPop() {
	cout << "- Testing pop()... " << flush;
	// try empty, capacity 1
	Stack<int> s1(1);
	assert( s1.isEmpty() );
    try {
            s1.peekTop();
            cerr << "\npeekTop() worked on empty stack (size 1)\n";
            exit(1);
    } catch (StackException& se) {
            cout << " 0a " << flush;
    }
	try {
		s1.pop();
		cerr << "\npop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 0b " << flush;
	}

	// try empty, capacity > 1
	Stack<int> s2(3);
	try {
		s2.pop();
		cerr << "\npop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 1a " << flush;
	}
    try {
            s2.peekTop();
            cerr << "\npeekTop() worked on empty stack (size 3)\n";
            exit(1);
    } catch (StackException& se) {
            cout << " 1b " << flush;
    }

	// try non-empty, capacity 1
	Stack<int> s3(1);
	s3.push(11);
	assert( s3.peekTop() == 11 );
	assert( s3.pop() == 11 );
	cout << " 2 " << flush;
	try {
		s3.pop();
		cerr << "\ns3.pop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 2a " << flush;
	}
    try {
            s3.peekTop();
            cerr << "\ns3.peekTop() worked on empty stack (size 1)\n";
            exit(1);
    } catch (StackException& se) {
            cout << " 2b " << flush;
    }

	// try non-empty, capacity > 1
	Stack<int> s4(3);
	s4.push(11);
	s4.push(22);
	s4.push(33);
	assert( s4.peekTop() == 33 );
	assert( s4.pop() == 33 );
	assert( s4.peekTop() == 22 );
	assert( s4.pop() == 22 );
	assert( s4.peekTop() == 11 );
	assert( s4.pop() == 11 );
	cout << " 3 " << flush;
	try {
		s4.pop();
		cerr << "\ns4.pop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 3a " << flush;
	}
    try {
            s4.peekTop();
            cerr << "\ns4.peekTop() worked on empty stack (size 3)\n";
            exit(1);
    } catch (StackException& se) {
            cout << " 3b " << flush;
    }

	cout << " Passed!" << endl;
}

void StackTester::testCopyConstructor() {
	cout << "- Testing copy constructor... " << flush;
	// minimal empty Stack
	Stack<int> s1(1);
	Stack<int> s2(s1);
	assert( s2.isEmpty() );
	assert( s2.myArray != NULL );
	assert( s2.myCapacity == 1 );
	assert( s2.myArray != s1.myArray );
	cout << " 1 " << flush;
	// minimal non-empty Stack
	Stack<int> s3(1);
	s3.push(11);
	Stack<int> s4(s3);
	assert( !s4.isEmpty() );
	assert( s4.isFull() );
	assert( s4.peekTop() == 11 );
	assert( s4.myArray != s3.myArray );
	cout << " 2 " << flush;
	// non-minimal, non-empty stack
	Stack<int> s5(3);
	s5.push(11);
	s5.push(22);
	s5.push(33);
	Stack<int> s6(s5);
	assert( s6.myCapacity == s5.myCapacity );
	assert( s6.mySize == s5.mySize );
	assert( s6.myArray != s5.myArray );
	assert( s6.pop() == 33 );
	assert( s6.pop() == 22 );
	assert( s6.pop() == 11 );
	assert( s5.peekTop() == 33 );
	cout << " 3 " << flush;
	cout << "Passed!" << endl;
}

void StackTester::testAssignment() {
	cout << "- Testing assignment... " << flush;
	// minimal empty Stacks, same size
	Stack<int> s1(1);
	Stack<int> s2(1);
	s2 = s1;
	assert( s2.isEmpty() );
	assert( s2.myArray != NULL );
	assert( s2.myArray != s1.myArray );
	assert( s2.myCapacity == 1 );
	cout << " 1 " << flush;
	// minimal non-empty Stack to empty Stack, same capacity
	Stack<int> s3(1);
	s3.push(11);
	Stack<int> s4(1);
	s4 = s3;
	assert( !s4.isEmpty() );
	assert( s4.isFull() );
	assert( s4.peekTop() == 11 );
	assert( s4.myArray != s3.myArray );
	cout << " 2 " << flush;
	// minimal empty stack to non-empty stack, same capacity
	Stack<int> s5(1);
	Stack<int> s6(1);
	s6.push(11);
	s6 = s5;
	assert( s6.isEmpty() );
	assert( s6.myArray != NULL );
	assert( s6.myArray != s5.myArray );
	assert( s6.myCapacity == 1 );
	cout << " 3 " << flush;
	// non-minimal non-empty stack to empty stack, different capacities
	Stack<int> s7(3);
	s7.push(11);
	s7.push(22);
	s7.push(33);
	Stack<int> s8(2);
	s8 = s7;
	assert( s8.myArray != s7.myArray );
	assert( s8.myCapacity == s7.myCapacity );
	assert( s8.mySize == s7.mySize );
	assert( s8.pop() == 33 );
	assert( s8.pop() == 22 );
	assert( s8.pop() == 11 );
	assert( s7.peekTop() == 33 );
	cout << " 4 " << flush;
	// non-minimal, empty stack to non-empty stack, different capacities
	Stack<int> s9(2);
	Stack<int> s10(3);
	s10.push(11);
	s10.push(22);
	s10.push(33);
	s10 = s9;
	assert( s10.isEmpty() );
	assert( s10.myArray != s9.myArray );
	assert( s10.myCapacity == s10.myCapacity );
	cout << " 5 " << flush;
	// self-assignment, minimal size
	Stack<int> s11(1);
	s11.push(11);
	s11 = s11;
	assert( s11.isFull() );
	assert( !s11.isEmpty() );
	cout << " 6 " << flush;
	// chaining
	Stack<int> s12(2);
	s12.push(11);
	s12.push(22);
	Stack<int> s13(1);
	Stack<int> s14(1);
	s14 = s13 = s12;
	assert( s14.isFull() );
	assert( s14.myArray != s13.myArray );
	assert( s14.myArray != s12.myArray );
	assert( s14.pop() == 22 );
	assert( s14.pop() == 11 );
	assert( s14.isEmpty() );
	cout << " 7 " << flush;
      // self-assignment, non-minimal size
      s13 = s13;
	assert( !s13.isEmpty() );
	assert( s13.isFull() );
	assert( s13.pop() == 22 );
	assert( s13.pop() == 11 );
	assert( s13.isEmpty() );
	cout << " 8 " << flush;
	cout << "Passed!" << endl;
}

void StackTester::testDestructor() {
	cout << "- Testing destructor..." << flush;
	// minimal, empty
	Stack<int> s1(1);
	s1.~Stack();
	assert( s1.isEmpty() );
	assert( s1.myArray == NULL );
	assert( s1.myCapacity == 0 );
	cout << " 1 " << flush;
	// minimal, non-empty
	Stack<int> s2(1);
	s2.push(11);
	s2.~Stack();
	assert( s2.isEmpty() );
	assert( s2.myArray == NULL );
	assert( s2.myCapacity == 0 );
	cout << " 2 " << flush;
	// non-minimal, empty
	Stack<int> s3(3);
	s3.~Stack();
	assert( s3.isEmpty() );
	assert( s3.myArray == NULL );
	assert( s3.myCapacity == 0 );
	cout << " 3 " << flush;
	// non-minimal, non-empty
	Stack<int> s4(3);
	s4.push(11);
	s4.push(22);
	s4.push(33);
	s4.~Stack();
	assert( s4.isEmpty() );
	assert( s4.myArray == NULL );
	assert( s4.myCapacity == 0 );
	cout << " 4 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testGetSize() {
	cout << "- Testing getSize..." << flush;
	Stack<int> s1(1);
	assert ( s1.getSize() == 0 );
	s1.push(11);
	assert ( s1.getSize() == 1 );
	cout << " 1 " << flush;
	Stack<int> s2(4);
	assert ( s2.getSize() == 0 );
	s2.push(11);
	assert ( s2.getSize() == 1 );
	s2.push(22);
	assert ( s2.getSize() == 2 );
	s2.push(33);
	assert ( s2.getSize() == 3 );
	s2.push(44);
	assert ( s2.getSize() == 4 );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testGetCapacity() {
	cout << "- Testing getCapacity..." << flush;
	Stack<int> s1(1);
	assert ( s1.getCapacity() == 1 );
	assert ( s1.getSize() == 0 );
	s1.push(11);
	assert ( s1.getCapacity() == 1 );
	assert ( s1.getSize() == 1 );
	cout << " 1 " << flush;
	Stack<int> s2(4);
	assert ( s2.getCapacity() == 4 );
	assert ( s2.getSize() == 0 );
	s2.push(11);
	assert ( s2.getCapacity() == 4 );
	assert ( s2.getSize() == 1 );
	s2.push(22);
	assert ( s2.getCapacity() == 4 );
	assert ( s2.getSize() == 2 );
	s2.push(33);
	assert ( s2.getCapacity() == 4 );
	assert ( s2.getSize() == 3 );
	s2.push(44);
	assert ( s2.getCapacity() == 4 );
	assert ( s2.getSize() == 4 );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testSetCapacity() {
	cout << "- Testing setCapacity..." << flush;
	Stack<int> s1(1);
	assert ( s1.getCapacity() == 1 );
	s1.push(11);
	assert ( s1.getSize() == 1 );
	assert ( s1.peekTop() == 11);
	s1.setCapacity(2);
	assert ( s1.getCapacity() == 2 );
	assert ( s1.getSize() == 1 );
	assert ( s1.peekTop() == 11);
	s1.push(22);
	assert ( s1.getSize() == 2 );
	assert ( s1.peekTop() == 22);
	assert ( s1.pop() == 22);
	assert ( s1.peekTop() == 11);
	cout << " 1 " << flush;
	Stack<int> s2(5);
	s2.push(11);
	s2.push(22);
	s2.push(33);
	s2.push(44);
	s2.push(55);
	assert ( s2.getCapacity() == 5 );
	try {
		s2.setCapacity(4);
		cerr << "\ns3.pop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (StackException& se) {
		cout << " 2a " << flush;
	}
	assert ( s2.getCapacity() == 5 );
	assert ( s2.pop() == 55 );
	assert ( s2.peekTop() == 44 );
	s2.setCapacity(4);
	assert ( s2.getCapacity() == 4 );
	cout << " 2b " << flush;
	Stack<int> s3(3);
	assert ( s3.getCapacity() == 3);
	s3.setCapacity(2);
	assert ( s3.getCapacity() == 2);
	s3.setCapacity(1);
	assert ( s3.getCapacity() == 1);
	s3.setCapacity(0);
	assert ( s3.getCapacity() == 0);
	cout << " 3 " << flush;
	// setCapacity with another stack's capacity
	assert ( s3.getCapacity() == 0);
	assert ( s2.getCapacity() == 4 );
	s3.setCapacity(s2.getCapacity());
	assert ( s3.getCapacity() == 4);\
	cout << " 4 " << flush;
	cout << " Passed!" << endl;
}
ck45@thompson:~/workspace/112/proj07$ cat ReversePoemTester.h
/*
 * ReversePoemTester.h
 *
 *  Created on: 2017. 3. 30.
 *      Author: Chan Kim
 */

#ifndef REVERSEPOEMTESTER_H_
#define REVERSEPOEMTESTER_H_

class ReversePoemTester {
public:
	void runTests();
	void testMethods();
};

#endif /* REVERSEPOEMTESTER_H_ */
ck45@thompson:~/workspace/112/proj07$ cat ReversePoemTester.cpp
/*
 * ReversePoemTester.cpp
 *
 *  Created on: 2017. 3. 30.
 *      Author: Chan Kim
 */

#include "ReversePoemTester.h"
#include "ReversePoem.h"
#include <iostream>  // cout, cerr, ...
#include <cassert>   // assert()
#include <cstdlib>   // exit()
using namespace std;

void ReversePoemTester::runTests() {
	cout << "Testing ReversePoem class..." << endl;
	testMethods();
	cout << "All tests passed!" << endl;
}

void ReversePoemTester::testMethods() {
	cout << "- Testing methods getTitle(), getAuthor(), getBody(), and getBodyReversed()... " << flush;
	// test to read a file, and compare it with the same file.
	ReversePoem rp1("anorexia.txt");
	assert( rp1.getTitle() == "Anorexia");
	assert( rp1.getAuthor() == "Anonymous");
	ReversePoem rp2("anorexia.txt");
	assert( rp1.getBody() == rp2.getBody());
	assert( rp1.getBody() != rp1.getBodyReversed());
	assert( rp2.getBody() != rp2.getBodyReversed());
	assert( rp2.getBodyReversed() == rp2.getBodyReversed());
	cout << " 1 " << flush;
	// test to read a file, and compare it with a different file.
	ReversePoem rp3("love.txt");
	assert( rp3.getTitle() == "Love?");
	assert( rp3.getAuthor() == "Anonymous");
	assert( rp3.getBody() != rp1.getBody());
	cout << " 2 " << flush;
	// test to read a file and check getBody and getBodyReversed methods with expected strings.
	ReversePoem rp4("cats.txt");
	assert( rp4.getTitle() == "Cats");
	assert( rp4.getAuthor() == "Leo J. Smada");
	assert( rp4.getBody() == "I love it when cats rub against me.\nI could never say\nI hate those purring felines.\n\n\n");
	assert( rp4.getBodyReversed() == "\n\nI hate those purring felines.\nI could never say\nI love it when cats rub against me.\n");
	cout << " 3 " << flush;
	cout << " Passed!" << endl;
}
ck45@thompson:~/workspace/112/proj07$ cd Debug
ck45@thompson:~/workspace/112/proj07/Debug$ ls
main.d	    proj07		 ReversePoemTester.o  StackTester.d  tester.o
main.o	    ReversePoem.d	 sources.mk	      StackTester.o
makefile    ReversePoem.o	 Stack.d	      subdir.mk
objects.mk  ReversePoemTester.d  Stack.o	      tester.d
ck45@thompson:~/workspace/112/proj07/Debug$ make all
make: Nothing to be done for 'all'.
ck45@thompson:~/workspace/112/proj07/Debug$ cd ..
ck45@thompson:~/workspace/112/proj07$ ./Debug/proj07
Testing Stack class...
- Testing constructor... *** StackException in Stack(size): size must be positive! 1  2  Passed!
- Testing isEmpty()...  1  2  Passed!
- Testing push()...  1  2  Passed! 
- Testing pop()...  0a  0b  1a  1b  2  2a  2b  3  3a  3b  Passed!
- Testing copy constructor...  1  2  3 Passed!
- Testing assignment...  1  2  3  4  5  6  7  8 Passed!
- Testing destructor... 1  2  3  4  Passed!
- Testing getSize... 1  2  Passed!
- Testing getCapacity... 1  2  Passed!
- Testing setCapacity... 1  2a  2b  3  4  Passed!
All tests passed!
Testing ReversePoem class...
- Testing methods getTitle(), getAuthor(), getBody(), and getBodyReversed()...  1  2  3  Passed!
All tests passed!
ck45@thompson:~/workspace/112/proj07$ / ./Debug/proj07

Enter the name of the poem file: cats.txt
Cats
Leo J. Smada

*** Top-To-Bottom ***

I love it when cats rub against me.
I could never say
I hate those purring felines.




*** Bottom-To-Top ***



I hate those purring felines.
I could never say
I love it when cats rub against me.

ck45@thompson:~/workspace/112/proj07$ ./Debug/proj07

Enter the name of the poem file: A anorexia.txt
Anorexia
Anonymous

*** Top-To-Bottom ***

I hate the girl in the mirror
so you'll never hear me say that
I'm good enough
I know in my heart that
the number on the scale defines my worth
and that
being thin will make me happy
I refuse to believe that there is hope
I'm ashamed of my body
No longer can I say
I am worth fighting for.




*** Bottom-To-Top ***



I am worth fighting for.
No longer can I say
I'm ashamed of my body
I refuse to believe that there is hope
being thin will make me happy
and that
the number on the scale defines my worth
I know in my heart that
I'm good enough
so you'll never hear me say that
I hate the girl in the mirror

ck45@thompson:~/workspace/112/proj07$ exit

Script done on Mon 03 Apr 2017 06:32:21 PM EDT
